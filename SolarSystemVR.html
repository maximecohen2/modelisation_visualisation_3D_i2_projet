<!DOCTYPE html>
<html lang="en">
<head>
    <title>Solar System VR</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
</head>
<body>


<script src="js/HelioWebXRPolyfill.js"></script>

<script type="module">

    import * as THREE from './js/three.module.js';
    import { OrbitControls } from './js/OrbitControls.js';
    import { VRButton } from './js/VRButton.js';
    import { data, backgroundTextures, mainObjectName } from './js/data.js';

    let textureLoader = new THREE.TextureLoader();
    let cubeTextureLoader =  new THREE.CubeTextureLoader();

    let container;
    let camera, scene, renderer;
    let controller1, controller2;

    let raycaster, intersected = [];
    let tempMatrix = new THREE.Matrix4();

    let controls, group;

    //

    var curve = new THREE.CubicBezierCurve3(
        new THREE.Vector3( 0,  0, 15),
        new THREE.Vector3( 90, 0, 15),
        new THREE.Vector3( 90, 0, 15),
        new THREE.Vector3( 0, 0, 15)

    );

    var points = curve.getPoints(10000);
    var geometryCurve = new THREE.BufferGeometry().setFromPoints(points);
    var material = new THREE.LineBasicMaterial();
    var curveObject = new THREE.Line(geometryCurve, material);

    var sphere = new THREE.Mesh(new THREE.SphereGeometry());



    /* ---------------------- curve  ----------------------*/

    var vitesse = 0.5;

    var start = null;

    init();
    requestAnimationFrame(animate);

    function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        scene = new THREE.Scene();
        scene.background = cubeTextureLoader.load(backgroundTextures);

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );
        camera.position.set( 0, 1.6, 3 );

        controls = new OrbitControls( camera, container );
        controls.target.set( 0, 1.6, 0 );
        controls.update();

        var ambientLight = new THREE.AmbientLight(0xffffff, .1);
        scene.add(ambientLight);

        // solar light
        var light = new THREE.PointLight( 0xffffff, 2, 1000);
        light.position.set( 0, 0, 0);
        scene.add( light );
        var light2 = new THREE.PointLight( 0xffffff, 2, 20);
        light2.position.set( -15, 0, 0);
        scene.add( light2 );
        var light22 = new THREE.PointLight( 0xffffff, 2, 20);
        light22.position.set( 15, 0, 0);
        scene.add( light22 );
        var light3 = new THREE.PointLight( 0xffffff, 2, 20);
        light3.position.set(0, 0, 15);
        scene.add( light3 );
        var light4 = new THREE.PointLight( 0xffffff, 2, 20);
        light4.position.set( 0, 0,-15);
        scene.add( light4 );
        var light5 = new THREE.PointLight( 0xffffff, 2, 20);
        light5.position.set(0, -15, 0);
        scene.add( light5 );
        var light6 = new THREE.PointLight( 0xffffff, 2, 20);
        light6.position.set(0, 15, 0);
        scene.add( light6 );

        //

        let sphereGeometry = new THREE.SphereGeometry(.5, 32, 32);
        let ringGeometry = new THREE.TorusGeometry( .5, .2, 2, 121);

        let objects = {};
        let textureLoadedCol = 'textureLoaded';
        let materialCol = 'material';
        let meshCol = 'mesh';
        let groupCol = 'group';

        for (let [key, value] of Object.entries(data)) {

            let object = {};
            objects[key] = object;

            // Create group
            object[groupCol] = new THREE.Group();

            if ('color' in value)
            {
                // Load Textures from data
                object[textureLoadedCol] = textureLoader.load(value['color']);

                // Create Materials for each objects in data
                object[materialCol] = new THREE.MeshStandardMaterial();

                // Generate mesh with materials
                if (value['mesh'] === "sphere")
                {
                    object[meshCol] = new THREE.Mesh(sphereGeometry, object[materialCol]);
                }
                else
                {
                    object[meshCol] = new THREE.Mesh(ringGeometry, object[materialCol]);
                    object[meshCol].rotateX(THREE.Math.degToRad(90));
                }

                // Set Material to Mesh
                object[meshCol].material.map = object[textureLoadedCol];

                // set Mesh size
                if ('size' in value)
                {
                    object[meshCol].scale.set(value['size'], value['size'], value['size']);
                }

                // Add Mesh to the group
                object[groupCol].add(object[meshCol]);
            }

            if ('parent' in value)
            {
                // Add object group to Parent group
                objects[value['parent']][groupCol].add(object[groupCol]);
            }

            if ('distance' in value)
            {
                object[groupCol].position.x = value['distance'];
            }

        }
        console.log(objects);

        group = new THREE.Group();
        scene.add( group );

        group.add(objects[mainObjectName][groupCol]);


        //

        curveObject.visible = false;
        scene.add(curveObject);

        scene.add(sphere);

        camera.position.z = 30;
        camera.position.y = 5;


        //

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;
        container.appendChild( renderer.domElement );

        document.body.appendChild( VRButton.createButton( renderer ) );

        // controllers

        controller1 = renderer.xr.getController( 0 );
        controller1.addEventListener( 'selectstart', onSelectStart );
        controller1.addEventListener( 'selectend', onSelectEnd );
        scene.add( controller1 );

        controller2 = renderer.xr.getController( 1 );
        controller2.addEventListener( 'selectstart', onSelectStart );
        controller2.addEventListener( 'selectend', onSelectEnd );
        scene.add( controller2 );

        //

        let geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

        let line = new THREE.Line( geometry );
        line.name = 'line';
        line.scale.z = 5;

        controller1.add( line.clone() );
        controller2.add( line.clone() );

        raycaster = new THREE.Raycaster();

        // Set Event Resize Screen

        window.addEventListener( 'resize', onWindowResize, false );
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onSelectStart( event ) {

        let controller = event.target;

        let intersections = getIntersections( controller );

        if ( intersections.length > 0 ) {

            let intersection = intersections[ 0 ];

            tempMatrix.getInverse( controller.matrixWorld );

            let object = intersection.object;
            object.matrix.premultiply( tempMatrix );
            object.matrix.decompose( object.position, object.quaternion, object.scale );
            object.material.emissive.b = 1;
            controller.add( object );

            controller.userData.selected = object;

        }

    }

    function onSelectEnd( event ) {

        let controller = event.target;

        if ( controller.userData.selected !== undefined ) {

            let object = controller.userData.selected;
            object.matrix.premultiply( controller.matrixWorld );
            object.matrix.decompose( object.position, object.quaternion, object.scale );
            object.material.emissive.b = 0;
            group.add( object );

            controller.userData.selected = undefined;

        }


    }

    function getIntersections( controller ) {

        tempMatrix.identity().extractRotation( controller.matrixWorld );

        raycaster.ray.origin.setFromMatrixPosition( controller.matrixWorld );
        raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );

        return raycaster.intersectObjects( group.children );

    }

    function intersectObjects( controller ) {

        // Do not highlight when already selected

        if ( controller.userData.selected !== undefined ) return;

        let line = controller.getObjectByName( 'line' );
        let intersections = getIntersections( controller );

        if ( intersections.length > 0 ) {

            let intersection = intersections[ 0 ];

            let object = intersection.object;
            object.material.emissive.r = 1;
            intersected.push( object );

            line.scale.z = intersection.distance;

        } else {

            line.scale.z = 5;

        }

    }

    function cleanIntersected() {

        while ( intersected.length ) {

            let object = intersected.pop();
            object.material.emissive.r = 0;

        }

    }

    //

    function animate(t) {

        if (start == null) {
            start = t;
        }
        var delai = t - start;

        curve.getPoint((delai * vitesse * .0001) % 1, camera.position);
        requestAnimationFrame(animate);
        renderer.setAnimationLoop( render );

    }

    function render() {

        cleanIntersected();

        intersectObjects( controller1 );
        intersectObjects( controller2 );

        renderer.render( scene, camera );

    }

</script>
</body>
</html>
